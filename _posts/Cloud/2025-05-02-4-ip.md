---
title: "VPC 배우기 전 사전지식: IP, 서브넷, CIDR"
description: "VPC에 대해 배우기 전 핵심 개념, IP와 클래스, 서브넷, CIDR에 대해 알아보자"
fa_icon: fa-solid fa-cloud
author: yulmwu
date: 2025-05-02 00:00:00 +0900
categories: ["A. 개념/용어 정리", "클라우드/AWS"]
tags: ["VPC", "IP", "서브넷", "CIDR"]
use_math: true
previous_post: 
    title: "EC2란?"
    path: "3-ec2"
next_post: 
    title: "VPC란?"
    path: "5-vpc"
series: 
    title: "클라우드/AWS 개념 정리"
    color: "bg-notion-yellow"
    ep: 4
    ep_color: "bg-notion-blue"
order: 1004
---

# 사전지식: IP/Public IP/Private IP

네트워크 정리에서 나온 내용이겠지만 **IP(Internet Protocol)**은 **네트워크 상 통신을 위해 부여되는 주소**임.

원래 컴퓨터(정확히는 NIC=Network Interface Card)에 MAC 주소라는 고정된 주소가 박혀있는데, 얘만 써선 정확히 찾기가 힘듬.

그래서 IP 주소를 써서(네트워크 계층) 라우팅하는 것. IPv4 IPv6가 있지만 이건 따로 알아보도록하고..

**Public IP**는 말 그대로 공개된 IP라는 것. **즉 인터넷(네트워크)에서 공개적으로 엑세스가 가능하도록 한 IP 주소임**. 즉 모든 인터넷 사용자가 접근이 가능하는 것.

반면 **Private IP**는 **로컬 네트워크(라우터나 스위치 등 내부)에서 사용되는 IP임**. 얘네는 인터넷 세상 밖으로 나가진 못하지만, 그 안에 내부 네트워크 내에선 라우터 등의 장비를 거치지 않기 때문에 내부적으로 통신할땐 빠르게 통신이 가능함.

IP는 **네트워크 ID** + **호스트 ID** 구성으로 생겼음.

예를 들어 `192.168.0.1` 이라면 `192.168.0`이 네트워크 주소, `1`이 호스트 ID를 의미함.

그래서 만약 `192.168.0.10`과 `192.168.20`이 있다면 두 IP는 같은 네트워크에 속한 IP임.

그리고 IPv4 기준으로 8비트(1바이트)씩 `.` 으로 4등분이 구분되어 있는데, 각각을 **옥텟(Octet)**이라 부름.

각 옥텟의 범위는 8비트니 0~255 범위를 가짐. 대충 총 42억개 정도를 가질 수 있는데, 이게 부족해짐에 따라 IPv6가 나온거임. (심지어 사용할 수 없거나 실험용 주소도 있어서 실제론 좀 더 적음)

이건 따로 공부하시고..

# 사전지식: IP 클래스

그럼 왜 굳이 옥텟을 나눴을까? 물론 보기 쉬우라고 나눈것도 있겠다만 이러한 옥텟 별로 **클래스**를 나누기 위함임.

클래스가 뭐냐.. 아까 IP는 네트워크 ID + 호스트 ID로 구성되어있다고 했는데, 그걸 구분하는 기준이 클래스임.

**어디까지가 네트워크 ID고 어디까지가 호스트 ID인지를 나타내는게 클래스라는거.**

나누는 이유는 네트워크의 규모와 사용 용도에 따라 호스트의 수를 정하는 것.

![ip-class](https://scythe-snowplow-4f2.notion.site/image/attachment%3A32e3bdf3-47ea-4938-b2c2-c12b30468c12%3Aimage.png?table=block&id=1e27c27c-3ffb-80da-bd15-cef24443aabf&spaceId=f9a3130a-e956-4548-ada7-6ae50608d32b&width=2000&userId=&cache=v2)

> 클래스에 대해 쉽게 이해하기 위해선 2진법에 대해 살짝이나마 아는게 편함.

## Class A

대규모 네트워크에서 사용되는 클래스. **첫번째 옥텟이 2진수에서 `0xxx xxxx`로 시작함(시작 비트).**

즉 맨 앞의 0이 고정되면서, 첫번째 옥텟의 범위가 `0`(`0000 0000b`) ~ `127`(`0111 1111`)로 제한됨.

또한 호스트 ID는 첫번째 옥텟을 제외한 3개의 옥텟으로 표현할 수 있음.

```jsx
0000 0000 . [ 0000 0000 . 0000 0000 . 0000 0000 ] (0.[0.0.0])
~
0111 1111 . [ 1111 1111 . 1111 1111 . 1111 1111 ] (127.[255.255.255])

// [ ]는 호스트 ID를 의미함
```

그래서 네트워크 주소의 범위의 수는 7비트(`2^7`개, 첫번째 옥텟에서 1비트 제외), 호스트의 개수는 (`2^24 - 2`개, 3개의 옥텟)를 가짐.

왜 2개가 빠지는지에 대해선 잠시 후에 설명 할 예정. 미리 설명하자면 2개가 빠지는건 모든 클래스에서도 동일함.

만약 `115.138.71.185` 라는 IP가 있다면, `115`는 0~127 사이의 범위이므로 클래스 A, 때문에 `115`는 네트워크 ID를 의미하며 `138.71.185`는 호스트 ID를 의미함.

> **`0.x.x.x`와 `127.x.x.x`는 일반적인 IP로 쓰지 않는다.**
> 
> `0.x.x.x`(첫번째 옥텟 `0`)은 컴퓨터가 자신의 IP를 모르는 경우, 통신 시 사용되는 IP임.
> 
> 예를 들어 IP를 할당 받기 전, 자신의 IP를 모를 때 DHCP에 `0.0.0.0` IP 주소와 MAC 주소로 보내고, 받아온 IP를 자신의 IP로 설정함.
> 
> `127.x.x.x`(첫번째 옥텟 `127`)은 루프백(데이터를 보내면 다시 자신에게 돌아오는 것) 용도로 쓰이는 IP 주소로, 예를 들어 `127.0.0.1`은 자신을 가리키는 IP 주소임.
> 
> 쉽게 말해 자신의 컴퓨터를 스스로 서버로 만들고, 그렇게 네트워크 구축 없이 네트워크 처럼 응답을 주고받을 수 있게 하는 것.
> 
> 참고로 `localhost`는 `127.0.0.1`의 도메인 이름으로, 이건 변경이 가능하지만 대부분 같은 주소를 가리킨다고 보면 됨.
> {: .prompt-info }

> **시작 비트를 제외한 나머지 비트가 전부 `0`이거나 `255`면 일반적인 IP로 사용할 수 없다.**
> 
> 아까 클래스 A의 호스트는 `2^24 - 2`로 제한된다고 하였는데, 여기서 2가 바로 시작 비트를 제외란 나머지 비트가 전부 `0`이거나 `255`일때를 의미함.
> 
> 나머지 비트가 전부 0이라면 해당 네트워크 ID 자체를 가리키고, 전부 `255`라면 브로드캐스트 주소임.
> 
> 만약 IP가 `10.0.0.0` 이라면 네트워크 ID `10` 그 자체를 의미, IP가 `10.255.255.255`를 의미하면 해당 네트워크 ID(`10`)에 속한 모든 네트워크 호스트와 통신하라는 의미임.
> 
> (물론 실제로 그렇게 많은 호스트에게 보내지도 못할 뿐더러 후술할 서브넷 단위로 브로드캐스팅함)
{: .prompt-info }

## Class B

중간 규모 정도의 네트워크에서 사용되는 클래스임.

**첫 옥텟은 2진수에서 `10xx xxx` 이며**, 네트워크 ID는 시작 옥텟 2개, 호스트 ID는 나머지 2개임.

범위는 아래와 같으며 마찬가지로 네트워크의 개수는 두 비트를 제외한 `2^14`개, 호스트의 개수는 `2^16 - 2`개임.

```jsx
1000 0000 . 0000 0000 . [ 0000 0000 . 0000 0000 ] (128.0.[0.0])
~
1011 1111 . 1111 1111 . [ 1111 1111 . 1111 1111 ] (191.255.[255.255])

// [ ]는 호스트 ID를 의미함
```

## Class C

소규모 정도의 네트워크에서 할당해서 씀.

**첫 옥텟은 2진수에서 `110x xxxx` 이며**, 네트워크 ID는 시작 옥텟 3개, 호스트 ID는 나머지 1개임.

범위는 아래와 같으며 마찬가지로 네트워크의 개수는 세 비트를 제외한 `2^21`개, 호스트의 개수는 `2^8 - 2`개임.

```jsx
1100 0000 . 0000 0000 . 0000 0000 . [ 0000 0000 ] (192.0.0.[0])
~
1101 1111 . 1111 1111 . 1111 1111 . [ 1111 1111 ] (223.255.255.[255])

// [ ]는 호스트 ID를 의미함
```

## Class D, E

첫 옥텟의 범위가 `224`(`1110 0000`)~`239`(`1110 1111`), `240`(`1111 0000`)~`255`(`1111 1111`)으로 제한되어 있고, 일반적인 용도가 아니기 때문에 호스트 이런거 없이 미리 정해진 IP가 있음.

몰라도 됨.

# 근데 사실 요즘엔 클래스는 안씀..

생각을 해보자. 예를 들어 어느 기업에서 필요로 하는 호스트의 개수는 1000개인데, 그럼 어느 클래스에 해당되는게 좋을까? A클래스에선 약 1670만개, B클래스에선 약 6만 5천개, C클래스에선 256개의 호스트를 가짐.

그럼 그 기업에선 B 클래스를 선택해야할텐데, **그럼 남는 6만 4천개 가량의 IP가 그대로 낭비됨.** 

즉 오히려 비효율적이게 된다는 것.
근데 왜 쓰지도 않는 클래스를 배웠냐? ⇒ 그걸 알아야 아래의 개념들을 이해할 수 있음.

아무튼 그래서 **서브넷(Subnet)**이란 개념이 등장함. 요즘엔 이걸 씀.

# 사전지식: 서브넷/서브넷 마스크

**서브넷(Subnet)**은 Sub + Network의 뜻을 가짐. 즉 네트워크가 분할되어 작은 네트워크로 나눠진 것.

이렇게 작게 분할하는걸 **서브네팅(Subnetting)**이라 함.

그래서 만약 아까 어느 기업에서 1000개의 호스트가 필요하다면, B클래스로 나누지 않고 서브네팅으로 1024개 정도의 IP만 나누는 것.

이렇게 서브네팅을 위해 IP를 계산하기 위해선 **서브넷 마스크(Subnet Mask)**라는게 필요함.

## 서브넷 마스크(Subnet Mask)

클래스 방식에선 클래스라는 개념으로 네트워크를 나누고 특정 범위를 네트워크 ID, 남는 뒷 부분을 호스트 ID로 지정했다면,  **서브넷에선 서브넷 마스크로 네트워크 ID와 호스트 ID를 구분함.**

서브넷 마스크도 IP와 같은 형식을 가지며, 즉 32비트로 나태냄.

그런데 서브넷 마스크는 형식이 2진수에서 연속된 `1`과 연속된 `0`이 이어져야함. 즉 아래처럼.

```java
255 . 255 . 255 . 0
=>
1111 1111 . 1111 1111 . 1111 1111 . 0000 0000
```

위와 같은 서브넷 마스크는 IP 뒤에 `/24`로 붙게 되는데, 눈치 빠르면 알거임. 슬래시(`/`) 뒤 숫자는 `1`이 몇개인지를 나타냄.

즉 `192.168.0.1/24` 라는 IP와 서브넷 마스크가 있다면 `192.168.0`이 네트워크 ID 부분이고, 호스트 ID 부분의 범위는 `1`~`254`(`0`과 `255` 제외)라는 것.

그래서 연속된 `1`과 연속된 `0`이 이어져야 했다는 거임.

(그게 아니라면 어디가 네트워크 부분인지, 호스트 부분인지 구분이 불가능함)

실제 장비나 컴퓨터에서도 AND 연산으로 계산하면 쉽게 네트워크 부분과 호스트 부분을 계산할 수 있음.

그럼 아까 배웠던 클래스에서 떠오르는게 있어야함. 클래스에선 클래스별로 호스트의 범위가 정해져 있다고 했는데, 이것도 당연히 서브넷 마스크로 나타낼 수 있음.

A 클래스는 네트워크 부분이 8비트니 `/8`, B 클래스는 `/16`, C 클래스는 `/24`가 되고, 얘네를 **기본 서브넷 마스크라** 부름.

# 사전지식: CIDR

클래스에서 서브넷 마스크라는게 있다고 배웠다. 그런데 전에 배웠지만 클래스는 남는 IP가 있어서 비효율적이라 했음. 그래서 **클래스 개념 없이(Classless) IP의 호스트와 네트워크 부분을 나눌 수 있는게 CIDR**임.

**(Classless Inter Domain Routing)**

사실 아까 서브넷 마스크에서 다 배운 내용임. 예를 들어서 A 클래스에선 서브넷 마스크가 `/8`, 즉 `255.0.0.0` 이라고 배웠는데 **슬래시 다음 숫자를 적는게 CIDR 표기법**임.

그리고 여기선 `/9` 같이 기본 클래스가 아닌 애들도 올 수 있는데, 이게 CIDR이고.

`/9`를 서브넷 마스크로 나타내면 `255.128.0.0`이 되겠지?

만약 `193.213.53.2/9` 라는 IP와 CIDR이 있다면, 아래와 같이 해석할 수 있음.

- `193.213.53.2` ⇒ 현재 IP 주소
- CIDR `/9` ⇒ 서브넷 마스크 `255.128.0.0`
- 네트워크 주소 ⇒ `193.128.0.0`
- 유효한 IP 범위 ⇒ `193.128.0.1` ~ `193.255.255.254`

```java
현재 IP 주소 => 193.213.53.2 (1100 0001 . 1101 0101 . 0011 0101 . 0000 0010)
서브넷 마스크 => 255.128.0.0  (1111 1111 . 1000 0000 . 0000 0000 . 0000 0000)
네트워크 주소 => 193.128.0.0  (1100 0001 . 1000 0000 . 0000 0000 . 0000 0000)
유효한 IP 범위:
193.128.0.1 (1100 0001 . 1000 0000 . 0000 0000 . 0000 0001)
~
193.255.255.254 (1100 0001. 1111 1111 . 1111 1111 . 1111 1110)
```

추가) 만약 `193.12.53.2/9` 라는 IP와 CIDR이 있다면, 아래와 같이 해석할 수 있음.

- `193.12.53.2` ⇒ 현재 IP 주소
- CIDR /9 ⇒ 서브넷 마스크 `255.128.0.0`
- 네트워크 주소 ⇒ `193.0.0.0`
- 유효한 IP 범위 ⇒ `193.0.0.1` ~ `193.127.255.254`

```java
현재 IP 주소 => 193.12.53.2 (1100 0001 . 0000 1100 . 0011 0101 . 0000 0010)
서브넷 마스크 => 255.128.0.0 (1111 1111 . 1000 0000 . 0000 0000 . 0000 0000)
네트워크 주소 => 193.0.0.0   (1100 0001 . 0000 0000 . 0000 0000 . 0000 0000)
유효한 IP 범위:
193.0.0.1 (1100 0001 . 0000 0000 . 0000 0000 . 0000 0001)
~
193.127.255.254 (1100 0001 . 0111 1111 . 1111 1111 . 1111 1110)
```

### 서브넷 마스크/CIDR 쉽게 계산하기

10진법으로 계산하면 헷갈리 아주 쉬움. 그래서 무조건 2진법으로 변환해서 계산하는게 편하고, 서브넷 마스크 계산할땐 AND 연산을 하면 됨. 

방금 예제는 아래와 같이 계산됨.

```java
IP            => 1100 0001 . 0000 1100 . 0011 0101 . 0000 0010
Subnet Mask   => 1111 1111 . 1000 0000 . 0000 0000 . 0000 0000 (/9)
Network Addr  => 1100 0001 . 0000 0000 . 0000 0000 . 0000 0000 (AND 연산)

Usable IP Min => 1100 0001 . 0000 0000 . 0000 0000 . 0000 0001
Usable IP Max => 1100 0001 . 0111 1111 . 1111 1111 . 1111 1110
```

그럼 아까 `193.213.53.2/9`도 쉽게 계산할 수 있겠지?

```java
IP            => 1100 0001 . 1101 0101 . 0011 0101 . 0000 0010
Subnet Mask   => 1111 1111 . 1000 0000 . 0000 0000 . 0000 0000 (/9)
Network Addr  => 1100 0001 . 1000 0000 . 0000 0000 . 0000 0000 (AND 연산)

Usable IP Min => 1100 0001 . 1000 0000 . 0000 0000 . 0000 0001
Usable IP Max => 1100 0001 . 1111 1111 . 1111 1111 . 1111 1110
```

솔직히 이거 암산으론 우리 짬엔 어렵고(=못함) 틀리기도 쉬워서 그냥 계산기 쓰면 됨.

[구글에 서브넷 마스크 계산기 검색 ㄱㄱ](https://www.calculator.net/ip-subnet-calculator.html)
